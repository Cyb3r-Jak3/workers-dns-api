{"version":3,"file":"worker.js","mappings":";;;;;;;;;AAAA;;;;;;;;;;;;;;;ACAA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;;;;;;;;;;;;;;;ACRA;AAEA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvCA;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;;;;;;;;;;;;;;;ACzCA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;;AC/BA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AACA;AACA;AAFA;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://dns-api/./node_modules/itty-router/dist/itty-router.min.js","webpack://dns-api/./src/dns-query.ts","webpack://dns-api/./src/dns-servers.ts","webpack://dns-api/./src/dns-utils.ts","webpack://dns-api/./src/index.ts","webpack://dns-api/./src/utils.ts","webpack://dns-api/webpack/bootstrap","webpack://dns-api/webpack/before-startup","webpack://dns-api/webpack/startup","webpack://dns-api/webpack/after-startup"],"sourcesContent":["module.exports={Router:({base:t=\"\",routes:l=[]}={})=>({__proto__:new Proxy({},{get:(e,a,o)=>(e,...r)=>l.push([a.toUpperCase(),RegExp(`^${(t+e).replace(/(\\/?)\\*/g,\"($1.*)?\").replace(/\\/$/,\"\").replace(/:(\\w+)(\\?)?(\\.)?/g,\"$2(?<$1>[^/]+)$2$3\").replace(/\\.(?=[\\w(])/,\"\\\\.\")}/*$`),r])&&o}),routes:l,async handle(e,...r){let a,o,t=new URL(e.url);e.query=Object.fromEntries(t.searchParams);for(var[p,s,u]of l)if((p===e.method||\"ALL\"===p)&&(o=t.pathname.match(s))){e.params=o.groups;for(var c of u)if(void 0!==(a=await c(e.proxy||e,...r)))return a}}})};\n","import { DNSQuery, DEFAULT_DOH_SERVER } from './dns-utils'\nimport { JSONErrorResponse, JSONResponse } from './utils'\n\nexport interface QueryRequest {\n  server: string\n  type: string\n  question: string\n}\n\nexport async function queryEndpoint(req: Request): Promise<Response> {\n  const query: QueryRequest = await req.json()\n  if (query.server === undefined) {\n    query.server = DEFAULT_DOH_SERVER\n  }\n  if (query.question === undefined || query.type === undefined) {\n    return JSONErrorResponse(\"Need both'question', and 'type' set\", 400)\n  }\n  const DNSResult = await DNSQuery(query)\n  if (DNSResult.Status === -1) {\n    return JSONErrorResponse('Error getting DNS Response')\n  }\n  return JSONResponse(DNSResult)\n}\n","import { DNSCRYPT_RESOLVERS } from './dns-utils'\nimport { JSONErrorResponse, JSONResponse } from './utils'\n\nconst DNS_CRYPT_INFO_URL =\n  'https://download.dnscrypt.info/dnscrypt-resolvers/json/public-resolvers.json'\n\nexport async function DNSCryptInfo(): Promise<Response> {\n  return await DNSCRYPT_RESPONSE()\n}\n\nexport async function GetUsedDNSServer(): Promise<Response> {\n  let servers: DNSCRYPT_RESOLVERS[] | null = await KEYS.get(\"DoH_SERVERS\", {type: \"json\"})\n  if (servers === null) {\n    const list: DNSCRYPT_RESOLVERS[] = await (await DNSCRYPT_RESPONSE()).json()\n    let usedDNSServer: DNSCRYPT_RESOLVERS[] = []\n    list.forEach((server) => {\n      if (server.nofilter && server.proto === 'DoH') {\n        usedDNSServer.push(server)\n      }\n    })\n    servers = usedDNSServer\n    await KEYS.put(\"DoH_SERVERS\", JSON.stringify(usedDNSServer), {expirationTtl: 86400})\n  }\n  return JSONResponse(servers)\n}\n\nasync function DNSCRYPT_RESPONSE(): Promise<Response> {\n  const cache = caches.default\n  let response = await cache.match(DNS_CRYPT_INFO_URL)\n  if (!response) {\n    const result = await fetch(DNS_CRYPT_INFO_URL, {\n      headers: { accept: 'application/json' },\n    })\n    if (result.status !== 200) {\n      console.error(result.statusText)\n      return JSONErrorResponse('Error getting upstream info')\n    }\n    response = JSONResponse(await result.json())\n    cache.put(DNS_CRYPT_INFO_URL, response.clone())\n  }\n  return response\n}\n","import { QueryRequest } from './dns-query'\n\nexport const DEFAULT_DOH_SERVER = 'https://cloudflare-dns.com/dns-query'\n\nexport interface DNSQuestion {\n  name: string\n  type: number\n}\n\nexport interface DNSAnswer {\n  name: string\n  type: number\n  TTL: number\n  data: string\n}\n\nexport interface DNSResponse {\n  Status: number\n  TC: boolean\n  RD: boolean\n  RA: boolean\n  AD: boolean\n  Question: { name: string; type: number }[]\n  Answer: DNSAnswer[]\n}\n\nexport interface DNSCRYPT_RESOLVERS {\n  addrs: string[]\n  country: string\n  description: string\n  dnssec: boolean\n  ipv6: boolean\n  location: { lat: number; long: number }\n  name: string\n  nofilter: boolean\n  nolog: boolean\n  ports: number[]\n  proto: string\n  stamp: string\n}\n\nexport async function DNSQuery(query: QueryRequest): Promise<DNSResponse> {\n  const queryURL = new URL(query.server)\n  queryURL.search = new URLSearchParams({\n    name: query.question,\n    type: query.type,\n  }).toString()\n  const results = await fetch(queryURL.toString(), {\n    headers: { accept: 'application/dns-json' },\n  })\n  if (results.status !== 200) {\n    console.log('Query URL: ', queryURL.toString())\n    console.log(results.statusText)\n    return {\n      Status: -1,\n      TC: false,\n      AD: false,\n      RD: false,\n      RA: false,\n      Question: [],\n      Answer: [],\n    }\n  }\n  const dnsResults: DNSResponse = await results.json()\n  return dnsResults\n}\n","import { queryEndpoint } from './dns-query'\n\nimport { Router } from 'itty-router'\nimport { JSONErrorResponse } from './utils'\nimport { DNSCryptInfo, GetUsedDNSServer } from './dns-servers'\n\nconst router = Router()\n\nexport const MiddlewareJSONCheck = (request: Request): Response | undefined => {\n  const contentType = request.headers.get('content-type') || ''\n  if (!contentType.includes('application/json')) {\n    return JSONErrorResponse('Not a JSON Body', 400)\n  }\n}\n\nrouter.get('/', () => {\n  return new Response(\n    'Homepage for DNS API. Nothing here right now but there are other endpoints. Checkout the repo: https://github.com/Cyb3r-Jak3/workers-dns-api',\n  )\n})\n\nrouter.get('/nameservers/used', GetUsedDNSServer)\n\nrouter.get('/nameservers/all', DNSCryptInfo)\n\nrouter.get('/query', MiddlewareJSONCheck, queryEndpoint)\n\nrouter.all('*', () => new Response('404, not found!', { status: 404 }))\n\naddEventListener('fetch', (e) => {\n  e.respondWith(router.handle(e.request))\n})\n","export function JSONResponse(\n  ResponseData: string | unknown,\n  status = 200,\n  extra_headers?: string[][],\n): Response {\n  const send_headers = new Headers({\n    'content-type': 'application/json; charset=UTF-8',\n  })\n  if (extra_headers) {\n    extra_headers.forEach((element) => {\n      send_headers.append(element[0], element[1])\n    })\n  }\n  return new Response(JSON.stringify(ResponseData), {\n    status: status,\n    headers: send_headers,\n  })\n}\n\nexport function JSONErrorResponse(errMessage: string, status = 500): Response {\n  return JSONResponse({ Error: errMessage }, status)\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}